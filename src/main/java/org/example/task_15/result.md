Пример 1

Программа с внесённым изменением не скомпилируется, так как метод makeSound больше не существует в суперклассе Animal. В классе Cat метод makeSound всё ещё существует, но теперь он не переопределяет метод суперкласса, так как подходящего по сигнатуре метода больше нет.

При разработке важно быть осторожным с изменениями публичного интерфейса класса (в данном случае, публичных методов), особенно если есть наследники, которые от него зависят.

Пример 2

Программа не скомпилируется: public void makeSound(int numberOfSounds) не переопределяет метод суперкласса. Если мы хотим, чтобы такой метод все же присутствовал в классе Cat, то надо либо убирать @Override, делая этот метод принадлежащим только классу Cat, либо вносить изменения в интерфейс суперкласса, что, как и в первом примере, нарушает Open Close Principle.

Пример 3

В конфигурации Maven указаны две разные версии jackson-databind. Если код использует функциональность, добавленную в версии 2.12.5, а в рантайме будет подключена версия 2.9.10, то приложение может выбрасывать ошибки (NoSuchMethodError, ClassNotFoundException). Если же методы и классы будут в наличии, то мы можем получить неожидаемое поведение ввиду неопределенности с выбором версии в рантайме.

Вместо HashMap.class лучше использовать new TypeReference<>() {} из библиотеки Jackson, который позволяет передавать информацию о типе данных во время выполнения, включая generic-типы.

Также result во втором блоке try-catch будет недоступен, что связано с особенностями работы с областью видимости переменных в Java.